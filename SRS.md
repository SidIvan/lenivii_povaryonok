# SRS "Ленивый поварёнок"

## Introduction
Серёжа
### Purpose
Серёжа
### Document conventions
Серёжа
### Intended Audience and Reading Suggestions
Серёжа
### Project scope
Серёжа
### References
Серёжа
## Общее описание
### Функциональность продукта
Продукт должен состоять из нескольких взаимодействующих друг с другом модулей:
+ Клиентское android-приложение
+ Микросервис подбора рецептов (RecipeGenerator)
+ Микросервис для работы с фотографиями продуктов питания (PhotoParser)
+ Gateway-балансировщик

![Схема взаимодействия](https://i.imgur.com/LL30IsQ.png)
### Перспективы развития продукта
В отсутствие аналогов среди android-приложений, продукт может занять свою нишу на рынке. Для этого продукт должен быть:
+ Максимально простым в использовании пользователем.
+ Легко масштабируемым.
+ Открытым к развитию.
### Фокус группы
Предполагаемый потребитель является русскоговорящим. Выделяются две большие группы пользователей:
+ Желающий научиться готовить человек (неопытный повар).
+ Умеющий готовить, но желающий разнообразить свой рацион человек (опытный повар).
### Окружение системы
Клиентская часть продукта будет располагаться на мобильном-android устройстве потребителя. Доставка будет осуществляться через Google Play.

Серверная часть, а также база данных будут расположена на виртуальных машинах в Яндекс.Облаке. Операционная система Ubuntu 20.

## Системные особенности
### `PhotoParser.parseProducts`
### Описание
front-end отправляет фотографию набора продуктов питания на endpoint микросервиса PhotoParser, который с помощью модели детектинга пытается определить, что на ней изображено. Назначение - помочь пользователю быстро составить список имеющихся продуктов.
### Запуск
На этапе составления списка продуктов для генерации рецепта после нажатия на определённую кнопку пользователь загружает фото из памяти устройства.
### Детали реализации
Клиент посылает http POST запрос на API-Gateway с заголовком "Content-Type":"multipart/form-data", в теле которого находится фотография, затем запрос проксируется на PhotoParser. Микросервис принимает фотографию, подготавливает, после чего подаёт на вход заранее обученной модели детектинга. Распознанные классы возращаются клиенту в формате json.
### `PhotoParser.parseBar`
### Описание
front-end отправляет фотографию bar-кода товара на endpoint микросервиса PhotoParser, который определяет, что изображено на фото. Назначение - получить детальную информацию об имеющемся у пользователя товаре для более качественного подбора рецептов.
### Запуск
На этапе составления списка продуктов для генерации рецепта после нажатия на определённую кнопку пользователь загружает фото из памяти устройства.
### Детали реализации
Клиент посылает http POST запрос на API-Gateway с заголовком "Content-Type":"multipart/form-data", в теле которого находится фотография, затем запрос проксируется на PhotoParser. Микросервис принимает фотографию, подготавливает, после чего с помощью детерменированного алгоритма определяет код товара. Распознанный код возращется клиенту в формате json.
### System feature — `Interface.product_list.take_photo`, ввод данных в список с помощью камеры

#### Description and priority

Позволяет пользователю использовать камеру устройства и отправляет полученное изображение на back-end, чтобы выделить продукты.

#### Stimulus/Response sequences

* Стимул: Пользователь нажимает на соотвествующую кнопку.

* Реакция: Запуск камеры устройства для съёмки фотографий.

Опция использует камеру устройства для создания фотографии и передачи результата на дальнейшую обработку, добавляя полученный результат в список продуктов.

### System feature — `Interface.product_list.keyboard`, ручной ввод данных в список

#### Description and priority

Позволяет пользователю вручную редактировать список продуктов в текущем списке.

#### Stimulus/Response sequences

* Стимул: Пользователь выбирает элемент списка и/или нажимает соответствующую кнопку.

* Реакция: Изменение состава текущего списка продуктов.

Опция должна поддерживать добавление, удаление и изменение элементов списка продуктов, при этом не изменяя состояния других элементов.

### System feature — `Interface.gen_recepies`, создание списка рецептов по спику продуктов 

#### Description and priority

Передаёт back-end'у текущий список продуктов и ожидает список рецептов.

#### Stimulus/Response sequences

* Стимул: Пользователь нажимает соответствующую кнопку.

* Реакция: Приложение возвращает пользователю список рецептов.

Ручка, отправляющая текущий список продуктов на back-end.


## External interface requirements

### User interfaces

Пользовательский интерфейс должен:

* Демонстрировать пользователю текущий список продуктов

* Позволять редактировать список

    + С помощью камеры устройства, считывая продукты с фотографии

    + Вручную добавлять и удалять продукты из списка

* Обладать элементом взаимодействия, с помощью которого активный список продуктов конвертируется в список рецептов

![Диаграмма интерфейса](https://i.imgur.com/rSNEgAv.png)

### Software interfaces
Общее
### Hardware interfaces
Серёжа
### Communication interfaces
Для сервиса RecipeGiver будет соответствующий REST API, детально см. System features.

Сервис RecipeGiver будет обращаться с помощью соответствующих хранимых процедур к базе данных с рецептами.
## Non functional requirements
### Performance requirements
Так как наш проект пока находится на начальном этапе, мы предполагаем небольшую загрузку наших мощностей. Измеряя в численных метриках порядка 100 RPS (Requests per second).
### Safety requirements
Будет производится валидация данных на каждом из этапов обработки, а также везде, где возможно возникновение ошибок, будут написаны обработчики с логированием.
### Software quality attributes
Конечно к каждому сервису необходимо будет написать юнит и интеграционные тесты для базовой проверки их на работоспособность. Для оценки сложности кода планируется обсчитывать цикломатическую сложность при помощи соответствующих пакетов/библиотек для каждого из языков, применяемых в проекте. В качестве архитектуры системы планируется использовать вариант монолитной архитектуры. При разработке будем стараться придерживаться принципов SOLID. Написанный код будет приводиться к стандартам оформления, если таковые есть, как, например, PEP8 для Python, для Go же просто будем применять `gofmt` к каждому из файлов ради принятого единообразия, для Kotlin - `ktfmt`.
### Security requirements
Конкретных требований по безопасности данных мы не предъявляем, поскольку никаких авторизаций со стороны пользователя наш продукт не предполагает, человек просто сразу начинает сканировать и мы даем ему результат. С нашей же стороны мы используем базы данных, наполненные информацией из открытых источников, поэтому также к себе не предъявляем каких-либо особых требований.