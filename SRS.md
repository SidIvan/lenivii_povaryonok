# SRS "Ленивый поварёнок"

## Introduction

Ленивый поварёнок — это сервис для подпора рецептов блюд по имеющемуся списку продуктов. Сервис состоит из мобильного приложения на android для взаимодействия с пользователем и серверной части на базе микросервисной архитектуры. Особенностью сервиса должна стать возможность составлять список имеющихся продуктов не только с помощью текстового ввода, но и посредством фотографирования продуктов для их автоматического распознания.

### Purpose

Упростить мучительный процесс выбора блюда для приготовления, предоставив сервис для подбора блюд. Цель в том, чтобы пользователь имел возможность перечислить имеющиеся продукты с помощью выбора из огромного списка, по которому будет выполняться текстовый поиск, или, возможно, с помощью распознавания продуктов на фотографии. Далее у пользователя должна быть возможность нажать на кнопку, отправящую его запрос на сервер, и получить в качестве результата список "релевантных" блюд с рецептами. Формальное определение релевантности не зафиксировано, неформально это должны быть блюда, чей список ингридиентов в некотором смысле сильно пересекается со списком имеющихся у пользователя ингредиентов.

### Document conventions

Оговоримся сразу, в данном сервисе очень много степеней свободы: существует много удобных и полезных функций, которые хотелось бы иметь, но которые не описаны в данном документе, а во многих местах можно применить более "умные" алгоритмы чем те, которые предлагается реализовать в данном документе. Однако чтобы не закопаться и не остаться ни с чем предлагается реализовывать продукт итеративно. Все перечисленные здесь детали реализации не обязаны во всех будущих версиях продукта быть реализованы и реализованы именно приведённым образом, однако данный SRS документ — это описание версии, которую предлагается реализовать в данный момент. Далее о данном подходе мы будем говорить "текущая итерация".

- Пользовательское приложение — приложение, с которым взаимодействует пользователь. Вообще говоря в текущей итерации это только android приложение, и разработка других способов взаимодействия с пользователем пока даже не планируется. Но для абстракции пользовательской части от серверных микросервисов может использоваться это слово, так как микросервисам не важно, с чем именно взаимодействует пользователь: android-приложение, ios-приложение, web-сайт, настольная программа,...

### Intended Audience

Люди, готовящие еду, особенно люди, не имеющие в этом большого опыта.

### References

- База данных продуктов и рецептов, вариант 1: [https://ru.openfoodfacts.org/data](https://ru.openfoodfacts.org/data). Преимущества: много продуктов, рецептов и сопровождающих данных (интересные свойства блюд). Недостатки: нужно импортировать данные из MongoDB.

- База данных продуктов и рецептов, вариант 2: [https://www.kaggle.com/datasets/coolonce/recipes-and-interpretation-dim](https://www.kaggle.com/datasets/coolonce/recipes-and-interpretation-dim) Преимущества: довольно большая база, легко импортируется.

## Overall Description
Ваня
### Product perspective
Ваня
### Product features
Ваня
### User classes and characteristics
Ваня
### Operating environment
Ваня
### Design and implementation constraints
Ваня
### User documentation
Ваня
### Assumptions and dependencies
Ваня
## System features

### System feature — RecipeGiver.get_ingredients_list, получить список продуктов

#### Description and priority

Передать front-end'у список существующих продуктов питания. Компонент системы, с которым функционирует пользователь, должен иметь список всех существующих продуктов, чтобы проводить валидацию ввода пользователем названия продуктов на стороне пользователя. Имеет высший приоритет, так как блокирует работу front-end'а с пользователем.

#### Stimulus/Response sequences

Это http ручка, пользовательское приложение будет дёргать её один раз при запуске, чтобы получить актуальный список продуктов. Список состоит из названий и id, которые создаются на стороне RecipeGiver.

#### Request

`<TODO (я не знаю, что здесь)>/get_ingredients_list`, тело игнорируется

#### Response

В теле ответа json со следующими полями:

```json
{
    "version": "строка; версия ответа, пока только 1.0",
    "ingredients": [{"name": "строка; название на русском", "id": "число; id, выдаваемый RecipeGiver"},...],
    "timestamp": "число; время в которое список ингредиентов был таким",
}
```

#### Functional requirements

Список продуктов питания поддерживается в базе данных, вверенной микросервису RecipeGiver. В этой базе каждый продукт имеет уникальный числовой идентификатор, он и будет возвращаться. В случае изменения базы данных выданные id продуктов инвалидируются.

### System feature — RecipeGiver.get_recipe, получить рецепт по списку продуктов

#### Description and priority

Пользовательское приложение передаёт микросервису RecipeGiver список имеющихся у пользователя ингридиентов и ожидает получить список релевантных рецептов. Имеет средний приоритет.

#### Stimulus/Response sequences

Это http ручка, пользовательское приложение будет дёргать её всякий раз, когда захочет получить список рецептов по данному списку ингредиентов.

#### Request

`<TODO (я не знаю, что здесь)>/get_recipe`, тело содержит json со следующими полями:

```json
{
    "version": "строка; версия запроса, пока только 1.0",
    "ingredients_ids": ["число; id продукта, выданное RecipeGiver.get_ingredients_list",...],
    "ingredients_names": ["строка; название продукта от PhotoParser, его множество значений не согласовано с базой продуктов напрямую",...],
}
```

#### Response

В теле ответа json со следующими полями:

```json
{
    "version": "строка; версия запроса, пока только 1.0",
    "dishes": [
        {
            "name": "строка; название блюда",
            "id": "число; id блюда, выданное RecipeGiver",
            "photo": "строка; как-то сериализованные данные",
            "ingredients": ["число; id продукта",...],  // истинный состав блюда
            "recipe": "строка; рецепт, инструкция по приготовлению",
            "attributes": [
                {
                    "key": "строка, название атрибута",
                    "value": "строка, значение"
                },
                ...
            ],  // прочие атрибуты, например, источник
        },
        ...
    ]
    "timestamp": "строка; время отправки",
}
```

#### Functional requirements

<!-- Подбор блюда — процесс, потенциально ресурсозатратный, поэтому запустим новый поток для его исполнения, не блокируя весь сервис. TODO: нужно? -->

Подбор блюда состоит из двух этапов: идентификация продуктов, которые нашёл PhotoParser, и сам подбор.

1. На первом этапе для каждого названия продукта из массива `ingredients_names` подберём ближайшее название из известных RecipeGiver названий продуктов, в качестве метрики используем расстояние Левинштейна. В случае если минимальное расстояние больше некоторого порога (для определения которого ещё необходимо провести небольшой ресёрч), проигнорируем название продукта, в противном случае добавим соответствующий id в список айдишников имеющихся у пользователя продуктов. Вообще говоря расстояние Левинштейна — так себе метрика, в следующих итерациях можно будет заменить её на более умный поиск.

2. Сердце всего RecipeGiver, по какому правилу подбирать блюда --- вопрос сложный. В текущей итерации разработки RecipeGiver будет возвращать список блюд, эквивалентный списку, получающемуся по следующему правилу:

    - Пусть $A$ — множество имеющихся ингредиентов, а "R_i" — множество необходимых ингредиентов для приготовления $i-$го блюда, тогда
    - удалим из списка блюд те, у которых $\frac{|A\cap R_i|}{|A|}<0.75$;
    - отсортируем оставшиеся блюда по неубыванию величины $|R_i \setminus A|$;
    - вернём $10$ первых блюд из списка, если их меньше — вернём сколько есть (в том числе ноль).

    Алгоритм глупый, но для первой итерации в самый раз. Практически весь этап состоит из запроса к БД рецептов.

## External interface requirements
Кирилл
### User interfaces
Кирилл
### Software interfaces

RecipeGiver будет запущен как бинарник, скомпилированный Golang компилятором под нужную ОС и архитектуру.

### Hardware interfaces

RecipeGiver будет использовать СУБД PostgreSQL, почти наверное PostgreSQL-сервер будет запущен на Linux x86_64 (представление в памяти БД, управляемой PostgreSQL, зависит от платформы). В качестве носителя SSD или HDD, это влияет на оптимизационные настройки, но текущая цель: поднять хоть что-то рабочее, поэтому пока не важно.

### Communication interfaces
Ваня, Олег
## Non functional requirements
Олег
### Performance requirements
Олег
### Safety requirements
Олег
### Software quality attributes
Олег
### Security requirements
Олег
## Other requirements

## Appendix A: Glossary
?
## Appendix B: Analysis Models
?
## Appendix C: Issues list
?